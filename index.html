<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Lissajous Lab - Tweakpane Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.9/dist/tweakpane.min.js"></script>
    <style>
      :root {
        --bg-color: #08080c;
        --bg-pattern: #16161f;
        --accent: #f0c75e;
        --preview-size: 400px;
      }

      @media (prefers-color-scheme: light) {
        :root {
          --bg-color: #f0f1f5;
          --bg-pattern: #dcdde5;
          --accent: #f0c75e;
        }
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background-color: var(--bg-color);
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background-color 0.3s ease;
      }

      /* Background Grid */
      .canvas-bg {
        position: absolute;
        inset: 0;
        background-image: radial-gradient(
          circle at 1px 1px,
          var(--bg-pattern) 1px,
          transparent 0
        );
        background-size: 24px 24px;
        z-index: 0;
      }

      /* Centered Canvas Container */
      .canvas-wrapper {
        position: relative;
        z-index: 1;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        /* Canvas background is handled by SVG/Canvas logic, this is just the frame */
        transition: transform 0.2s;
        display: flex;
        justify-content: center;
        align-items: center;
        width: min(var(--preview-size), 90vmin);
        aspect-ratio: 1 / 1;
      }

      #preview {
        display: block;
        width: 100%;
        height: 100%;
      }

      /* Tweakpane Positioning */
      .tp-dfwv {
        position: fixed !important;
        top: 10px;
        right: 10px;
        left: auto;
        width: 300px !important;
        max-width: 90vw;
        z-index: 100;
        max-height: calc(100vh - 20px);
        overflow-y: auto;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35),
          0 1px 0 rgba(255, 255, 255, 0.04);
        border-radius: 6px;
        transform: none;
      }

      .tp-dfwv,
      .tp-dfwv button,
      .tp-dfwv [role="button"],
      .tp-dfwv input,
      .tp-dfwv select,
      .tp-dfwv a {
        touch-action: manipulation;
      }

      /* Scrollbar for Tweakpane content if it gets too tall */
      .tp-dfwv::-webkit-scrollbar {
        width: 6px;
      }
      .tp-dfwv::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 3px;
      }

      @media (max-width: 600px) {
        body {
          align-items: flex-end;
          padding-bottom: 24px;
        }
        .tp-dfwv {
          top: 12px;
          top: max(12px, env(safe-area-inset-top));
          left: 50%;
          right: auto;
          bottom: auto;
          width: 90vw !important;
          border-radius: 10px;
          max-height: calc(100vh - 24px);
          max-height: calc(
            100svh - 24px - env(safe-area-inset-top) - env(safe-area-inset-bottom)
          );
          max-height: calc(
            100dvh - 24px - env(safe-area-inset-top) - env(safe-area-inset-bottom)
          );
          transform: translateX(-50%);
        }
        .canvas-wrapper {
          transform: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="canvas-bg"></div>

    <div class="canvas-wrapper">
      <svg id="preview" width="400" height="400"></svg>
    </div>

    <canvas id="renderCanvas" style="display: none"></canvas>

    <script>
      /* =========================================
         1. COMPLETE GIF ENCODER (LZW)
         Included fully so no external deps needed
         ========================================= */
      class GIFEncoder {
        constructor(width, height) {
          this.width = width;
          this.height = height;
          this.frames = [];
          this.delay = 100;
        }
        setDelay(ms) {
          this.delay = ms;
        }
        addFrame(ctx) {
          const data = ctx.getImageData(0, 0, this.width, this.height).data;
          this.frames.push(this.quantize(data));
        }
        quantize(data) {
          const palette = new Uint8Array(256 * 3);
          const colors = new Map();
          for (let i = 0; i < data.length; i += 4) {
            // Skip transparent pixels for simple quantization
            if (data[i + 3] === 0) continue;
            const key = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];
            colors.set(key, (colors.get(key) || 0) + 1);
          }
          const sorted = [...colors.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 255);

          // Index 0 is reserved for transparency
          const transparentIdx = 0;

          // Fill palette
          let pIdx = 1;
          sorted.forEach(([c]) => {
            palette[pIdx * 3] = (c >> 16) & 255;
            palette[pIdx * 3 + 1] = (c >> 8) & 255;
            palette[pIdx * 3 + 2] = c & 255;
            pIdx++;
          });

          const indexed = new Uint8Array(this.width * this.height);
          for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] < 128) {
              indexed[i / 4] = transparentIdx;
              continue;
            }
            let minD = Infinity,
              idx = 1;
            const r = data[i],
              g = data[i + 1],
              b = data[i + 2];
            // Simple Euclidean distance
            for (let j = 1; j < pIdx; j++) {
              const dr = palette[j * 3] - r;
              const dg = palette[j * 3 + 1] - g;
              const db = palette[j * 3 + 2] - b;
              const dist = dr * dr + dg * dg + db * db;
              if (dist < minD) {
                minD = dist;
                idx = j;
              }
            }
            indexed[i / 4] = idx;
          }
          return { indexed, palette };
        }
        finish() {
          const bytes = [];
          const write = (...b) => bytes.push(...b);
          const writeStr = (s) =>
            [...s].forEach((c) => bytes.push(c.charCodeAt(0)));

          // Header
          writeStr("GIF89a");
          write(this.width & 255, this.width >> 8);
          write(this.height & 255, this.height >> 8);
          write(0xf7, 0, 0); // Global Color Table Flag

          // Use first frame's palette for Global Table (Simplified)
          if (this.frames.length > 0) {
            for (let i = 0; i < 256 * 3; i++)
              write(this.frames[0].palette[i] || 0);
          } else {
            for (let i = 0; i < 256 * 3; i++) write(0);
          }

          // Netscape Loop Extension
          write(0x21, 0xff, 0x0b);
          writeStr("NETSCAPE2.0");
          write(0x03, 0x01, 0x00, 0x00, 0x00);

          for (const frame of this.frames) {
            // GCE (Graphic Control Extension)
            write(0x21, 0xf9, 0x04);
            write(0x09); // Disposal (1) + Transparency Flag (1) -> 00001001
            write((this.delay / 10) & 255, (this.delay / 10) >> 8);
            write(0x00); // Transparent Color Index
            write(0x00); // Terminator

            // Image Descriptor
            write(0x2c, 0, 0, 0, 0);
            write(this.width & 255, this.width >> 8);
            write(this.height & 255, this.height >> 8);
            write(0x00); // Local Color Table Flag (0)

            // Image Data (LZW)
            const lzw = this.lzwEncode(frame.indexed, 8);
            write(8); // LZW Min Code Size
            for (let i = 0; i < lzw.length; i += 255) {
              const chunk = lzw.slice(i, i + 255);
              write(chunk.length, ...chunk);
            }
            write(0x00);
          }
          write(0x3b); // Trailer
          return new Uint8Array(bytes);
        }
        lzwEncode(data, minCodeSize) {
          const clearCode = 1 << minCodeSize;
          const eoiCode = clearCode + 1;
          let codeSize = minCodeSize + 1;
          let nextCode = eoiCode + 1;
          const table = new Map();
          const output = [];
          let bits = 0,
            buf = 0;
          const emit = (code) => {
            buf |= code << bits;
            bits += codeSize;
            while (bits >= 8) {
              output.push(buf & 255);
              buf >>= 8;
              bits -= 8;
            }
          };
          emit(clearCode);
          let prefix = data[0];
          for (let i = 1; i < data.length; i++) {
            const suffix = data[i];
            const key = (prefix << 12) | suffix;
            if (table.has(key)) {
              prefix = table.get(key);
            } else {
              emit(prefix);
              if (nextCode < 4096) {
                table.set(key, nextCode++);
                if (nextCode > 1 << codeSize && codeSize < 12) codeSize++;
              }
              prefix = suffix;
            }
          }
          emit(prefix);
          emit(eoiCode);
          if (bits > 0) output.push(buf);
          return output;
        }
      }

      /* =========================================
         2. APP STATE & LOGIC
         ========================================= */

      const PARAMS = {
        // Shape
        preset: "none",
        freqA: 3,
        freqB: 4,
        phase: 0,
        rotation: 0,
        scale: 85,
        resolution: 500,

        // Style
        strokeColor: "#f0c75e",
        strokeWidth: 2,
        strokeOpacity: 100,
        useGradient: false,
        strokeColor2: "#ec4899",
        lineCap: "round",
        lineJoin: "round",
        dash: "solid",

        useFill: false,
        fillColor: "#f0c75e",
        fillOpacity: 15,

        useBg: false,
        bgColor: "#08080c",

        // Canvas
        width: 400,
        height: 400,
        linkDims: true,
        // Animation
        animSpeed: 1,

        // Export
        pngScale: 2,
        gifDuration: 2,
        gifFps: 24,
        webmDuration: 3,
      };

      const PRESETS = {
        classic: { a: 3, b: 2, p: 90 },
        fish: { a: 3, b: 4, p: 0 },
        knot: { a: 5, b: 4, p: 90 },
        shield: { a: 3, b: 5, p: 45 },
        wing: { a: 7, b: 6, p: 0 },
        grid: { a: 10, b: 9, p: 0 },
      };

      let isAnimating = false;
      let animId = null;
      let currentPhase = 0; // The actual phase used during animation loop

      // --- SVG UPDATE LOGIC ---
      function update() {
        const svg = document.getElementById("preview");
        const {
          width,
          height,
          freqA,
          freqB,
          rotation,
          scale,
          resolution,
          strokeWidth,
        } = PARAMS;

        const previewSize = Math.min(width, height);
        document.documentElement.style.setProperty(
          "--preview-size",
          `${previewSize}px`
        );

        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

        const cx = width / 2;
        const cy = height / 2;
        const maxRadius = Math.min(width, height) / 2 - strokeWidth - 2;
        const amp = maxRadius * (scale / 100);

        const activePhase = isAnimating ? currentPhase : PARAMS.phase;
        const phaseRad = (activePhase * Math.PI) / 180;
        const rotRad = (rotation * Math.PI) / 180;

        let d = "M";
        for (let i = 0; i <= resolution; i++) {
          const t = (i / resolution) * Math.PI * 2;
          const x = amp * Math.sin(freqA * t + phaseRad);
          const y = amp * Math.sin(freqB * t);
          // 2D Rotation
          const rx = x * Math.cos(rotRad) - y * Math.sin(rotRad);
          const ry = x * Math.sin(rotRad) + y * Math.cos(rotRad);
          d += `${(cx + rx).toFixed(2)},${(cy + ry).toFixed(2)} `;
        }
        d += PARAMS.useFill ? "Z" : ""; // Close path if filled for better visuals, else open

        // Defs for gradient
        let defs = "";
        let strokeAttr = PARAMS.strokeColor;
        if (PARAMS.useGradient) {
          defs = `<defs>
            <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="${PARAMS.strokeColor}"/>
              <stop offset="100%" stop-color="${PARAMS.strokeColor2}"/>
            </linearGradient>
          </defs>`;
          strokeAttr = "url(#grad)";
        }

        let bgRect = "";
        if (PARAMS.useBg) {
          bgRect = `<rect width="100%" height="100%" fill="${PARAMS.bgColor}"/>`;
        }

        const dashMap = {
          solid: "",
          dashed: "10,10",
          dotted: "2,5",
          long: "20,5",
        };

        const content = `
          ${defs}
          ${bgRect}
          <path d="${d}"
            fill="${PARAMS.useFill ? PARAMS.fillColor : "none"}"
            fill-opacity="${PARAMS.useFill ? PARAMS.fillOpacity / 100 : 0}"
            stroke="${strokeAttr}"
            stroke-width="${strokeWidth}"
            stroke-opacity="${PARAMS.strokeOpacity / 100}"
            stroke-linecap="${PARAMS.lineCap}"
            stroke-linejoin="${PARAMS.lineJoin}"
            stroke-dasharray="${dashMap[PARAMS.dash]}"
          />
        `;
        svg.innerHTML = content;
      }

      function animLoop() {
        if (!isAnimating) return;
        currentPhase = (currentPhase + PARAMS.animSpeed) % 360;
        update();
        animId = requestAnimationFrame(animLoop);
      }

      function togglePlay() {
        isAnimating = !isAnimating;
        if (isAnimating) {
          currentPhase = PARAMS.phase;
          playBtn.title = "Pause Animation";
          animLoop();
        } else {
          cancelAnimationFrame(animId);
          playBtn.title = "Play Animation";
          // Sync slider back
          PARAMS.phase = Math.round(currentPhase);
          pane.refresh();
        }
      }

      /* =========================================
         3. RASTER RENDERER (Canvas 2D)
         Used for PNG, GIF, WebM export
         ========================================= */
      function renderToCanvas(ctx, phaseVal, w, h) {
        // Clear
        if (PARAMS.useBg) {
          ctx.fillStyle = PARAMS.bgColor;
          ctx.fillRect(0, 0, w, h);
        } else {
          ctx.clearRect(0, 0, w, h);
        }

        const { freqA, freqB, rotation, scale, resolution, strokeWidth } =
          PARAMS;

        const cx = w / 2;
        const cy = h / 2;
        // Adjust maxRadius based on scale of canvas vs base 400
        // We calculate ratio to scale stroke width appropriately
        const ratio = w / PARAMS.width;
        const actualStroke = strokeWidth * ratio;
        const maxRadius = Math.min(w, h) / 2 - actualStroke - 2 * ratio;
        const amp = maxRadius * (scale / 100);

        const phaseRad = (phaseVal * Math.PI) / 180;
        const rotRad = (rotation * Math.PI) / 180;

        ctx.beginPath();
        for (let i = 0; i <= resolution; i++) {
          const t = (i / resolution) * Math.PI * 2;
          const x = amp * Math.sin(freqA * t + phaseRad);
          const y = amp * Math.sin(freqB * t);
          const rx = x * Math.cos(rotRad) - y * Math.sin(rotRad);
          const ry = x * Math.sin(rotRad) + y * Math.cos(rotRad);
          if (i === 0) ctx.moveTo(cx + rx, cy + ry);
          else ctx.lineTo(cx + rx, cy + ry);
        }

        if (PARAMS.useFill) {
          ctx.fillStyle = PARAMS.fillColor;
          ctx.globalAlpha = PARAMS.fillOpacity / 100;
          ctx.fill(); // Auto closes
          ctx.globalAlpha = 1;
        }

        // Stroke
        if (PARAMS.useGradient) {
          const grad = ctx.createLinearGradient(0, 0, w, h);
          grad.addColorStop(0, PARAMS.strokeColor);
          grad.addColorStop(1, PARAMS.strokeColor2);
          ctx.strokeStyle = grad;
        } else {
          ctx.strokeStyle = PARAMS.strokeColor;
        }

        const dashMap = {
          solid: [],
          dashed: [10 * ratio, 10 * ratio],
          dotted: [2 * ratio, 5 * ratio],
          long: [20 * ratio, 5 * ratio],
        };
        ctx.setLineDash(dashMap[PARAMS.dash]);
        ctx.lineCap = PARAMS.lineCap;
        ctx.lineJoin = PARAMS.lineJoin;
        ctx.lineWidth = actualStroke;
        ctx.globalAlpha = PARAMS.strokeOpacity / 100;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      /* =========================================
         4. TWEAKPANE SETUP
         ========================================= */
      const pane = new Tweakpane.Pane({ title: "Lissajous Lab" });

      // -- TABS --
      const tabs = pane.addTab({
        pages: [
          { title: "Shape" },
          { title: "Style" },
          { title: "Canvas" },
          { title: "Export" },
        ],
      });

      const [tabShape, tabStyle, tabCanvas, tabExport] = tabs.pages;

      // -- TAB 1: SHAPE --
      tabShape
        .addInput(PARAMS, "preset", {
          options: {
            Custom: "none",
            "Classic (3:2)": "classic",
            "Goldfish (3:4)": "fish",
            "Knot (5:4)": "knot",
            "Shield (3:5)": "shield",
            "Wing (7:6)": "wing",
            "Net (10:9)": "grid",
          },
        })
        .on("change", (ev) => {
          if (ev.value !== "none") {
            const p = PRESETS[ev.value];
            PARAMS.freqA = p.a;
            PARAMS.freqB = p.b;
            PARAMS.phase = p.p;
            pane.refresh();
            if (!isAnimating) update();
          }
        });
      tabShape.addSeparator();
      tabShape
        .addInput(PARAMS, "freqA", {
          min: 1,
          max: 20,
          step: 1,
          label: "Freq A",
        })
        .on("change", update);
      tabShape
        .addInput(PARAMS, "freqB", {
          min: 1,
          max: 20,
          step: 1,
          label: "Freq B",
        })
        .on("change", update);
      tabShape
        .addInput(PARAMS, "phase", { min: 0, max: 360, label: "Phase" })
        .on("change", (ev) => {
          if (!isAnimating) {
            currentPhase = ev.value;
            update();
          }
        });
      tabShape
        .addInput(PARAMS, "rotation", { min: 0, max: 360, label: "Rotation" })
        .on("change", update);
      tabShape
        .addInput(PARAMS, "scale", { min: 10, max: 100, label: "Scale %" })
        .on("change", update);
      tabShape
        .addInput(PARAMS, "resolution", {
          min: 100,
          max: 2000,
          step: 50,
          label: "Points",
        })
        .on("change", update);

      const btnRand = tabShape.addButton({ title: "Randomize Shape" });
      btnRand.on("click", () => {
        PARAMS.freqA = Math.ceil(Math.random() * 10);
        PARAMS.freqB = Math.ceil(Math.random() * 10);
        PARAMS.phase = Math.floor(Math.random() * 360);
        PARAMS.preset = "none";
        pane.refresh();
        update();
      });

      // -- TAB 2: STYLE --
      const fStroke = tabStyle.addFolder({ title: "Stroke" });
      fStroke
        .addInput(PARAMS, "strokeColor", { label: "Color" })
        .on("change", update);
      fStroke
        .addInput(PARAMS, "strokeWidth", { min: 0.5, max: 20, label: "Width" })
        .on("change", update);
      fStroke
        .addInput(PARAMS, "strokeOpacity", {
          min: 0,
          max: 100,
          label: "Opacity",
        })
        .on("change", update);

      const iGrad = fStroke.addInput(PARAMS, "useGradient", {
        label: "Gradient",
      });
      const iGradCol = fStroke.addInput(PARAMS, "strokeColor2", {
        label: "End Color",
      });
      iGradCol.hidden = !PARAMS.useGradient;
      iGrad.on("change", (ev) => {
        iGradCol.hidden = !ev.value;
        update();
      });
      iGradCol.on("change", update);

      const fProps = tabStyle.addFolder({
        title: "Properties",
        expanded: false,
      });
      fProps
        .addInput(PARAMS, "lineCap", {
          options: { Round: "round", Butt: "butt", Square: "square" },
          label: "Cap",
        })
        .on("change", update);
      fProps
        .addInput(PARAMS, "lineJoin", {
          options: { Round: "round", Miter: "miter", Bevel: "bevel" },
          label: "Join",
        })
        .on("change", update);
      fProps
        .addInput(PARAMS, "dash", {
          options: {
            Solid: "solid",
            Dashed: "dashed",
            Dotted: "dotted",
            Long: "long",
          },
          label: "Pattern",
        })
        .on("change", update);

      const fFill = tabStyle.addFolder({ title: "Fill" });
      const iFill = fFill.addInput(PARAMS, "useFill", { label: "Enable" });
      const iFillCol = fFill.addInput(PARAMS, "fillColor", { label: "Color" });
      const iFillOp = fFill.addInput(PARAMS, "fillOpacity", {
        min: 0,
        max: 100,
        label: "Opacity",
      });
      iFillCol.hidden = !PARAMS.useFill;
      iFillOp.hidden = !PARAMS.useFill;
      iFill.on("change", (ev) => {
        iFillCol.hidden = !ev.value;
        iFillOp.hidden = !ev.value;
        update();
      });
      iFillCol.on("change", update);
      iFillOp.on("change", update);

      const fBg = tabStyle.addFolder({ title: "Background" });
      const iBg = fBg.addInput(PARAMS, "useBg", { label: "Fill BG" });
      const iBgCol = fBg.addInput(PARAMS, "bgColor", { label: "Color" });
      iBgCol.hidden = !PARAMS.useBg;
      iBg.on("change", (ev) => {
        iBgCol.hidden = !ev.value;
        update();
      });
      iBgCol.on("change", update);

      // -- TAB 3: CANVAS --
      tabCanvas
        .addInput(PARAMS, "width", { min: 50, max: 2000, step: 10 })
        .on("change", (ev) => {
          if (PARAMS.linkDims) {
            PARAMS.height = ev.value;
            pane.refresh();
          }
          update();
        });
      tabCanvas
        .addInput(PARAMS, "height", { min: 50, max: 2000, step: 10 })
        .on("change", update);
      tabCanvas.addInput(PARAMS, "linkDims", { label: "Link Dims" });
      tabCanvas.addSeparator();
      const btnReset = tabCanvas.addButton({ title: "Reset Defaults" });
      btnReset.on("click", () => {
        PARAMS.freqA = 3;
        PARAMS.freqB = 4;
        PARAMS.phase = 0;
        PARAMS.scale = 85;
        PARAMS.strokeColor = "#f0c75e";
        PARAMS.bgColor = "#08080c";
        pane.refresh();
        update();
      });

      // -- TAB 4: EXPORT --

      // Utils
      function tempTitle(btn, msg, orig) {
        btn.title = msg;
        setTimeout(() => {
          btn.title = orig;
        }, 2000);
      }
      function getSVGString() {
        const svg = document.getElementById("preview").cloneNode(true);
        svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        return new XMLSerializer().serializeToString(svg);
      }

      // 1. Vector
      const fVec = tabExport.addFolder({ title: "SVG (Vector)" });
      const btnSvgD = fVec.addButton({ title: "Download SVG" });
      btnSvgD.on("click", () => {
        const blob = new Blob([getSVGString()], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "lissajous.svg";
        a.click();
        URL.revokeObjectURL(url);
        tempTitle(btnSvgD, "Downloaded!", "Download SVG");
      });
      const btnSvgC = fVec.addButton({ title: "Copy SVG Code" });
      btnSvgC.on("click", async () => {
        await navigator.clipboard.writeText(getSVGString());
        tempTitle(btnSvgC, "Copied!", "Copy SVG Code");
      });

      // 2. Bitmap
      const fBit = tabExport.addFolder({ title: "PNG (Bitmap)" });
      fBit.addInput(PARAMS, "pngScale", {
        options: { "1x": 1, "2x": 2, "4x": 4 },
        label: "Scale",
      });
      const btnPngD = fBit.addButton({ title: "Download PNG" });
      btnPngD.on("click", async () => {
        const scale = PARAMS.pngScale;
        const cvs = document.createElement("canvas");
        cvs.width = PARAMS.width * scale;
        cvs.height = PARAMS.height * scale;
        renderToCanvas(
          cvs.getContext("2d"),
          isAnimating ? currentPhase : PARAMS.phase,
          cvs.width,
          cvs.height
        );

        cvs.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `lissajous-${scale}x.png`;
          a.click();
          URL.revokeObjectURL(url);
          tempTitle(btnPngD, "Downloaded!", "Download PNG");
        });
      });

      // 3. Animation
      const fAni = tabExport.addFolder({ title: "Animation" });
      fAni.addInput(PARAMS, "gifDuration", {
        min: 0.5,
        max: 10,
        label: "Duration(s)",
      });
      fAni.addInput(PARAMS, "gifFps", {
        options: { 15: 15, 24: 24, 30: 30 },
        label: "FPS",
      });

      const btnGif = fAni.addButton({ title: "Render GIF" });
      btnGif.on("click", async () => {
        if (btnGif.title !== "Render GIF") return;
        const origTitle = "Render GIF";
        const totalFrames = PARAMS.gifDuration * PARAMS.gifFps;
        const cvs = document.getElementById("renderCanvas");
        cvs.width = PARAMS.width;
        cvs.height = PARAMS.height;
        const ctx = cvs.getContext("2d", { willReadFrequently: true });

        const encoder = new GIFEncoder(cvs.width, cvs.height);
        encoder.setDelay(1000 / PARAMS.gifFps);

        const startP = PARAMS.phase;

        // Render Loop
        for (let i = 0; i < totalFrames; i++) {
          btnGif.title = `Rendering ${Math.round((i / totalFrames) * 100)}%`;
          // Allow UI update
          await new Promise((r) => setTimeout(r, 0));

          const p = (startP + (i / totalFrames) * 360) % 360;
          renderToCanvas(ctx, p, cvs.width, cvs.height);
          encoder.addFrame(ctx);
        }

        btnGif.title = "Encoding...";
        await new Promise((r) => setTimeout(r, 50));

        const gifData = encoder.finish();
        const blob = new Blob([gifData], { type: "image/gif" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "lissajous.gif";
        a.click();
        URL.revokeObjectURL(url);

        tempTitle(btnGif, "Done!", origTitle);
      });

      fAni.addSeparator();
      fAni.addInput(PARAMS, "webmDuration", {
        min: 1,
        max: 20,
        label: "WebM Len(s)",
      });
      const btnWebm = fAni.addButton({ title: "Record WebM" });
      btnWebm.on("click", () => {
        if (btnWebm.title !== "Record WebM") return;

        const cvs = document.getElementById("renderCanvas");
        cvs.width = PARAMS.width;
        cvs.height = PARAMS.height;
        const ctx = cvs.getContext("2d");
        const stream = cvs.captureStream(30);
        const recorder = new MediaRecorder(stream, { mimeType: "video/webm" });
        const chunks = [];

        recorder.ondataavailable = (e) => chunks.push(e.data);
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "lissajous.webm";
          a.click();
          tempTitle(btnWebm, "Saved!", "Record WebM");
        };

        recorder.start();
        const startP = PARAMS.phase;
        const duration = PARAMS.webmDuration * 1000;
        const startT = performance.now();

        function recLoop() {
          const elapsed = performance.now() - startT;
          if (elapsed >= duration) {
            recorder.stop();
            return;
          }
          const prog = elapsed / duration;
          btnWebm.title = `Rec: ${Math.round(prog * 100)}%`;

          const p = (startP + prog * 360) % 360;
          renderToCanvas(ctx, p, cvs.width, cvs.height);
          requestAnimationFrame(recLoop);
        }
        recLoop();
      });

      // -- GLOBAL FOOTER --
      pane.addSeparator();
      pane.addInput(PARAMS, "animSpeed", { min: 0.1, max: 5, label: "Speed" });
      const playBtn = pane.addButton({ title: "Play Animation" });
      playBtn.on("click", togglePlay);

      // Init
      update();
    </script>
  </body>
</html>
